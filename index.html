<!DOCTYPE html>
<html lang="et">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>BrowVision AI — MVP</title>
  <style>
    :root{
      --bg:#0f1115;
      --panel:#171922;
      --ink:#d9dbe1;
      --muted:#8b90a1;
      --accent:#7c5cff;
      --good:#1fd17f;
      --warn:#ffcc66;
      --bad:#ff6b6b;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background:radial-gradient(1200px 600px at 70% -10%, #1c2030 0%, #0f1115 60%);
      color:var(--ink);
      font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial;
      letter-spacing:.2px;
      -webkit-font-smoothing:antialiased;
      display:flex;
      flex-direction:column;
    }
    header{
      display:flex; align-items:center; justify-content:space-between;
      padding:14px 18px; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.1));
      border-bottom:1px solid #20242f88;
      position:sticky; top:0; z-index:10;
    }
    .brand{display:flex; gap:10px; align-items:center;}
    .logo{
      width:28px; height:28px; border-radius:8px;
      background:conic-gradient(from 120deg, #7c5cff, #38bdf8, #7c5cff);
      box-shadow:0 0 0 2px #ffffff10, 0 10px 30px #7c5cff33;
    }
    h1{font-size:16px; margin:0; font-weight:650; letter-spacing:.3px;}
    main{display:grid; grid-template-columns: 1.2fr .8fr; gap:16px; padding:16px; flex:1; min-height:0;}
    .card{
      background:var(--panel); border:1px solid #23283a; border-radius:14px;
      box-shadow:0 10px 40px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
      overflow:hidden;
    }
    .card h2{margin:0; font-size:14px; text-transform:uppercase; letter-spacing:.14em; color:var(--muted);}
    .card header{padding:12px 14px; border:0; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(0,0,0,.12));}
    .card section{padding:14px;}
    .stack{display:flex; gap:12px; align-items:center; flex-wrap:wrap;}
    .controls{display:grid; grid-template-columns:repeat(2,1fr); gap:10px;}
    label{display:flex; flex-direction:column; gap:6px; font-size:12px; color:var(--muted);}
    input[type="range"]{width:100%;}
    input[type="color"]{width:100%; height:36px; border-radius:10px; border:1px solid #2b314b; background:#0e111a; padding:0;}
    button{
      appearance:none; border:1px solid #2b314b; background:#101423; color:var(--ink);
      padding:10px 12px; border-radius:12px; font-weight:600; cursor:pointer;
    }
    button.primary{background:linear-gradient(180deg,#7c5cff,#6a4bff); border-color:#6a4bff; box-shadow:0 8px 30px #7c5cff44;}
    button.ghost{background:#131726;}
    button:disabled{opacity:.6; cursor:not-allowed;}
    .canvas-wrap{position:relative; aspect-ratio:3/4; width:100%; background:#0b0d14; border-radius:12px; overflow:hidden;}
    video, canvas{position:absolute; inset:0; width:100%; height:100%; object-fit:cover;}
    .badge{
      position:absolute; right:10px; top:10px; background:#0e1322dd; border:1px solid #2b314b; color:var(--muted);
      padding:6px 10px; border-radius:999px; font-size:12px; backdrop-filter: blur(4px);
    }
    .row{display:flex; gap:12px; align-items:center;}
    .grid{display:grid; grid-template-columns:1fr 1fr; gap:10px;}
    .muted{color:var(--muted);}
    .pill{display:inline-flex; gap:8px; align-items:center; padding:6px 10px; border-radius:999px; background:#111528; border:1px solid #2b314b; font-size:12px; color:var(--muted);}
    .stat{display:flex; flex-direction:column; gap:4px; padding:10px; border:1px dashed #343a55; border-radius:12px;}
    .stat b{font-size:18px;}
    footer{padding:10px 16px; color:#8b90a1aa; border-top:1px solid #20242f88;}
    textarea, select, input[type="text"]{
      width:100%; background:#101423; color:var(--ink); border:1px solid #2b314b; border-radius:10px; padding:10px;
      outline:none;
    }
    .mini{font-size:11px; color:var(--muted);}
    @media (max-width: 980px){
      main{grid-template-columns:1fr; }
    }
  </style>
</head>
<body>
<header>
  <div class="brand">
    <div class="logo" aria-hidden="true"></div>
    <h1>BrowVision AI — prototüüp</h1>
  </div>
  <div class="row">
    <span class="pill">MVP • kliendivaade</span>
  </div>
</header>

<main>
  <!-- LEFT: Camera + Overlay -->
  <div class="card" id="visionCard">
    <header class="row" style="justify-content:space-between;">
      <h2>Reaalajas analüüs</h2>
      <div class="row">
        <button id="startBtn" class="primary">Käivita kaamera</button>
        <button id="snapBtn" class="ghost" disabled>Tee kaader</button>
      </div>
    </header>
    <section>
      <div class="canvas-wrap">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
        <span class="badge" id="status">Valmis</span>
      </div>
      <div class="stack" style="margin-top:12px;">
        <div class="stat"><span class="mini">Kulmude sümmeetria</span><b id="symmetry">–</b></div>
        <div class="stat"><span class="mini">Soovitatud kaar</span><b id="arch">–</b></div>
        <div class="stat"><span class="mini">Paksus</span><b id="thickness">–</b></div>
      </div>
    </section>
  </div>

  <!-- RIGHT: Controls + GPT panel -->
  <div class="card">
    <header><h2>Seaded ja soovitused</h2></header>
    <section>
      <div class="controls">
        <label>Kaare intensiivsus
          <input id="archIntensity" type="range" min="0" max="100" value="55">
        </label>
        <label>Paksus
          <input id="thick" type="range" min="1" max="20" value="7">
        </label>
        <label>Peenhäälestus (sisemine punkt)
          <input id="innerAdjust" type="range" min="-20" max="20" value="0">
        </label>
        <label>Peenhäälestus (välimine punkt)
          <input id="outerAdjust" type="range" min="-20" max="20" value="0">
        </label>
        <label>Värv
          <input id="color" type="color" value="#c58a60">
        </label>
        <label>Õhulisus (läbipaistvus)
          <input id="alpha" type="range" min="10" max="100" value="70">
        </label>
      </div>
      <div class="stack" style="margin-top:10px;">
        <button id="resetBtn">Lähtesta</button>
        <button id="exportBtn">Salvesta enne/pärast</button>
      </div>

      <hr style="border:0;border-top:1px solid #2b314b; margin:14px 0">

      <div class="stack">
        <div class="pill">GPT-analüüs</div>
      </div>
      <p class="muted">Allpool on näidis, kuidas edastada kaader GPT-visioonmudelile personaalseks soovituseks. Avaliku võtmega brauseris <b>ära</b> jooksuta — tee läbi oma backendi (vt kood). </p>
      <label>Soovita stiili (lööklaused GPT-le)
        <textarea id="prompt" rows="5">Arvesta näokuju, silmade kuju ja loomulikku kulmujoont. Tee 3 konkreetset soovitust kulmu kaarele, paksusele ja toonile igapäevaseks, lavaks ja fotolooks. Lisa lühike põhjendus.</textarea>
      </label>
      <div class="row" style="justify-content:space-between; margin-top:8px;">
        <button id="askBtn" class="primary" disabled>Küsi GPT-lt (demo)</button>
        <button id="copyCurlBtn" class="ghost">Kopeeri cURL (serverisse)</button>
      </div>
      <pre id="gptOut" style="white-space:pre-wrap; background:#0c1020; border:1px solid #2b314b; padding:10px; border-radius:10px; margin-top:10px; max-height:240px; overflow:auto;">—</pre>
    </section>
  </div>
</main>

<footer>
  <small>© 2025 BrowVision AI • See on MVP-prototüüp. Kasutab MediaPipe Face Mesh’i kulmu-landmarkide tuvastuseks ja lihtsat geomeetriat kaare soovituse arvutamiseks.</small>
</footer>

<!-- MediaPipe Face Mesh -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>

<script>
(function(){
  const video = document.getElementById('video');
  const canvas = document.getElementById('overlay');
  const ctx = canvas.getContext('2d');
  const statusEl = document.getElementById('status');

  const archIntensity = document.getElementById('archIntensity');
  const thick = document.getElementById('thick');
  const innerAdjust = document.getElementById('innerAdjust');
  const outerAdjust = document.getElementById('outerAdjust');
  const color = document.getElementById('color');
  const alpha = document.getElementById('alpha');

  const symmetryEl = document.getElementById('symmetry');
  const archEl = document.getElementById('arch');
  const thicknessEl = document.getElementById('thickness');

  const startBtn = document.getElementById('startBtn');
  const snapBtn = document.getElementById('snapBtn');
  const exportBtn = document.getElementById('exportBtn');
  const resetBtn = document.getElementById('resetBtn');

  const promptEl = document.getElementById('prompt');
  const askBtn = document.getElementById('askBtn');
  const gptOut = document.getElementById('gptOut');
  const copyCurlBtn = document.getElementById('copyCurlBtn');

  let camera;
  let currentLandmarks = null;
  let lastFrameDataUrl = null;

  function setStatus(txt){
    statusEl.textContent = txt;
  }

  function resizeCanvas(){
    const rect = canvas.getBoundingClientRect();
    canvas.width  = rect.width  * devicePixelRatio;
    canvas.height = rect.height * devicePixelRatio;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  addEventListener('resize', resizeCanvas);

  // Utility: cubic bezier draw
  function drawCurve(points, width, rgba){
    ctx.save();
    ctx.lineWidth = width;
    ctx.strokeStyle = rgba;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    for(let i=1; i<points.length-2; i++){
      const xc = (points[i].x + points[i+1].x) / 2;
      const yc = (points[i].y + points[i+1].y) / 2;
      ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
    }
    ctx.quadraticCurveTo(points[points.length-2].x, points[points.length-2].y, points[points.length-1].x, points[points.length-1].y);
    ctx.stroke();
    ctx.restore();
  }

  // Compute "ideal" arch points from detected eyebrow landmarks with simple geometric rules.
  function computeBrowPath(landmarks, side /*'left'|'right'*/){
    // MediaPipe FaceMesh landmark indices reference for eyebrows (approx):
    // Left brow: 70..103 region; Right brow: 336..346 region (varies).
    // We'll pick a few stable points: inner (closest to nose), apex (highest), outer tail.
    // Fallback: derive from eye corner + forehead region.
    const idx = side === 'left'
      ? { inner:70, apex:105, outer:107 } // approx; may vary per model version
      : { inner:336, apex:334, outer:276 };

    // Clamp helpers
    const L = landmarks;
    function pick(i){
      // guard
      const j = Math.max(0, Math.min(L.length-1, i));
      const p = L[j];
      return {x:p.x * canvas.width, y:p.y * canvas.height};
    }

    let pIn = pick(idx.inner);
    let pAp = pick(idx.apex);
    let pOut = pick(idx.outer);

    // Adjust by UI
    pIn.x += Number(innerAdjust.value);
    pOut.x += Number(outerAdjust.value);

    // Arch intensity shifts apex upward (smaller y) and a bit outward
    const intensity = Number(archIntensity.value)/100;
    const raise = -20*intensity;
    pAp = {x:pAp.x + (side==='left'?-1:1)*6*intensity, y:pAp.y + raise};

    // Build smooth path with control points
    const points = [
      {x:pIn.x, y:pIn.y+3},
      {x:(pIn.x*2+pAp.x)/3, y:(pIn.y*2+pAp.y)/3},
      {x:(pIn.x+pAp.x)/2, y:(pIn.y+pAp.y)/2-3},
      {x:(pAp.x*2+pOut.x)/3, y:(pAp.y*2+pOut.y)/3},
      {x:pOut.x, y:pOut.y+4}
    ];
    return points;
  }

  function rgbaFromPick(){
    const c = color.value;
    const r = parseInt(c.slice(1,3),16);
    const g = parseInt(c.slice(3,5),16);
    const b = parseInt(c.slice(5,7),16);
    const a = Number(alpha.value)/100;
    return `rgba(${r},${g},${b},${a})`;
  }

  function updateStats(landmarks){
    if(!landmarks){ symmetryEl.textContent='–'; archEl.textContent='–'; thicknessEl.textContent='–'; return; }
    // Rough symmetry score: compare y of left/right apex
    const L = landmarks;
    const leftApex = L[Math.min(105, L.length-1)] || L[105-1];
    const rightApex = L[Math.min(334, L.length-1)] || L[334-1];
    const dy = Math.abs((leftApex?.y||0) - (rightApex?.y||0));
    const score = Math.max(0, 100 - Math.round(dy*1000));
    symmetryEl.textContent = score + '/100';
    archEl.textContent = Math.round(Number(archIntensity.value)) + '%';
    thicknessEl.textContent = Number(thick.value) + ' px';
  }

  function drawOverlay(){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    if(!currentLandmarks) return;
    const rgba = rgbaFromPick();
    const w = Number(thick.value);
    ['left','right'].forEach(side=>{
      const pts = computeBrowPath(currentLandmarks, side);
      drawCurve(pts, w, rgba);
    });
    updateStats(currentLandmarks);
  }

  // MediaPipe FaceMesh setup
  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  faceMesh.onResults(results => {
    resizeCanvas();
    currentLandmarks = null;
    if(results.multiFaceLandmarks && results.multiFaceLandmarks.length){
      currentLandmarks = results.multiFaceLandmarks[0].map(p=>({x:p.x, y:p.y}));
      setStatus('Tuvastatud');
    } else {
      setStatus('Ootan nägu…');
    }
    drawOverlay();
  });

  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'user'}, audio:false});
      video.srcObject = stream;
      await video.play();
      const CameraUtils = window;
      // camera from mediapipe
      camera = new Camera(video, {
        onFrame: async () => {
          await faceMesh.send({image: video});
        },
        width: 720, height: 960
      });
      camera.start();
      startBtn.disabled = true;
      snapBtn.disabled = false;
      askBtn.disabled = false;
      setStatus('Käib…');
    } catch(e){
      setStatus('Kaamera luba puudub');
      console.error(e);
    }
  }

  function takeSnapshot(){
    // capture current frame + overlay to a merged data URL
    const out = document.createElement('canvas');
    out.width = canvas.width; out.height = canvas.height;
    const octx = out.getContext('2d');
    octx.drawImage(video, 0, 0, out.width, out.height);
    octx.drawImage(canvas, 0, 0, out.width, out.height);
    lastFrameDataUrl = out.toDataURL('image/png', 0.95);
    return lastFrameDataUrl;
  }

  function exportBeforeAfter(){
    const w = canvas.width, h = canvas.height;
    const out = document.createElement('canvas');
    out.width = w*2; out.height = h;
    const octx = out.getContext('2d');
    // before
    octx.drawImage(video, 0, 0, w, h);
    // after
    octx.drawImage(video, w, 0, w, h);
    octx.drawImage(canvas, w, 0, w, h);
    const url = out.toDataURL('image/png', 0.95);
    const a = document.createElement('a');
    a.href = url; a.download = 'browvision-enne-parast.png';
    a.click();
  }

  // Demo GPT integration (prepare payload + cURL)
  function buildCurl(){
    const dataUrl = takeSnapshot();
    const base64 = dataUrl.split(',')[1];
    const userPrompt = promptEl.value.trim();
    const json = {
      model: "gpt-5-thinking",
      messages: [{
        role: "user",
        content: [
          {type:"text", text: userPrompt},
          {type:"input_image", image_url:{url:`data:image/png;base64,${base64}`}}
        ]
      }],
      temperature: 0.4
    };
    const curl = [
      'curl https://api.openai.com/v1/chat/completions \\',
      '  -H "Content-Type: application/json" \\',
      '  -H "Authorization: Bearer $OPENAI_API_KEY" \\',
      `  -d '${JSON.stringify(json).replace(/'/g,"'\\''")}'`
    ].join('\n');
    return curl;
  }

  function copyCurl(){
    const curl = buildCurl();
    navigator.clipboard.writeText(curl);
    gptOut.textContent = "cURL kopeeritud lõikepuhvrisse. Kasuta seda oma serveris (mitte brauseris).";
  }

  // UI bindings
  startBtn.onclick = startCamera;
  snapBtn.onclick = takeSnapshot;
  exportBtn.onclick = exportBeforeAfter;
  resetBtn.onclick = ()=>{
    archIntensity.value = 55;
    thick.value = 7;
    innerAdjust.value = 0;
    outerAdjust.value = 0;
    color.value = '#c58a60';
    alpha.value = 70;
    drawOverlay();
  };
  [archIntensity, thick, innerAdjust, outerAdjust, color, alpha].forEach(el=>{
    el.addEventListener('input', drawOverlay);
  });
  askBtn.onclick = ()=>{
    const curl = buildCurl();
    gptOut.textContent = curl + "\n\nNäidis. Soovitus: loo lihtne Node/Edge funktsioon, mis edastab pildi OpenAI API-le ja tagastab personaalse kirjaliku plaani.";
  };
  copyCurlBtn.onclick = copyCurl;

  // initial
  resizeCanvas();
  setStatus('Valmis');
})();
</script>
</body>
</html>
